[{"body":"Prerequisistes Luet currently supports Docker and Img as backends to build packages. Both of them can be used and switched in runtime with the --backend option, so either one of them must be present in the host system.\nDocker Docker is the (less) experimental Luet engine supported. Be sure to have Docker installed and the daemon running. The user running luet commands needs the corresponding permissions to run the docker executable, and to connect to a docker daemon. The only feature needed by the daemon is the ability to build images, so it fully supports remote daemon as well (this can be specified with the DOCKER_HOST environment variable, that is respected by luet)\nImg Luet supports Img. To use it, simply install it in your system, and while running luet build, you can switch the backend by providing it as a parameter: luet build --backend img. For small packages it is particularly powerful, as it doesn‚Äôt require any docker daemon running in the host.\nBuilding packages on Kubernetes Luet and img can be used together to orchestrate package builds also on kubernetes. There is available an experimental Kubernetes CRD for Luet which allows to build packages seamelessly in Kubernetes and push package artifacts to an S3 Compatible object storage (e.g. Minio).\nBuilding packages Luet provides an abstraction layer on top of the container image layer to make the package a first class construct. A package definition and all its dependencies are translated by Luet to Dockerfiles which can then be built anywhere that docker runs.\nTo resolve the dependency tree Luet uses a SAT solver and no database. It is responsible for calculating the dependencies of a package and to prevent conflicts. The Luet core is still young, but it has a comprehensive test suite that we use to validate any future changes.\nBuilding a package with Luet requires only a definition. This definition can be self-contained and be only composed of one specfile, or a group of them, forming a Luet tree. For more complex use-cases, see collections.\nRun luet build --help to get more help for each parameter.\nBuild accepts a list of packages to build, which syntax is in the category/name-version notation. See also specfile documentation page to see how to express packages from the CLI.\nEnvironmental variables Luet builds passes its environment variable at the engine which is called during build, so for example the environment variable DOCKER_HOST or DOCKER_BUILDKIT can be setted.\nEvery argument from the CLI can be setted via environment variable too with a LUET_ prefix, for instance the flag --clean, can be setted via environment with LUET_CLEAN, --privileged can be enabled with LUET_PRIVILEGED and so on.\nAdditionally, you can set:\n DOCKER_SQUASH: Set to true to squash each image being created (Docker backend only)  Supported compression format At the moment, luet can compress packages and tree with zstd and gzip. For example:\nluet build --compression zstd ... Will output package compressed in the zstd format.\nSee the --help of create-repo and build to learn all the available options.\nExample A package definition is composed of a build.yaml and a sibiling definition.yaml.\nIn the following example, we are creating a dummy package (bar/foo). Which ships one file only, /foo\n$\u003e # put yourself in some workdir $~/workdir\u003e mkdir package $~/workdir\u003e cat \u003c\u003cEOF \u003e package/build.yaml image: busybox steps: - echo \"foo=bar\" \u003e /foo EOF $~/workdir\u003e cat \u003c\u003cEOF \u003e package/definition.yaml name: \"foo\" version: \"0.1\" category: \"bar\" EOF To build it, simply run luet build bar/foo or luet build --all to build all the packages in the current directory:\n$\u003e luet build --all üì¶ Selecting foo 0.1 üì¶ Compiling foo version 0.1 .... ‚òï üêã Downloading image luet/cache-foo-bar-0.1-builder üêã Downloading image luet/cache-foo-bar-0.1 üì¶ foo Generating üêã definition for builder image from busybox üêã Building image luet/cache-foo-bar-0.1-builder üêã Building image luet/cache-foo-bar-0.1-builder done Sending build context to Docker daemon 4.096kB ... Luet ‚Äútrees‚Äù are just a group of specfiles, in the above example, our tree was the current directory. You can also specify a directory with the --tree option. Luet doesn‚Äôt enforce any tree layout, so they can be nested at any level. The only rule of thumb is that a build.yaml file needs to have either a definition.yaml or a collection.yaml file next to it.\nNesting dependencies In the example above we have created a package from a delta. Luet by default creates packages by analyzing the differences between the generated containers, and extracts the differences as archive, the resulting files then are compressed and can be consumed later on by luet install.\nLuet can create packages from different strategies: by delta, by taking a whole container content, or by considering a single directory in the build container. See the package definition for more details.\nExample Let‚Äôs extend the above example with two packages which depends on it during the build phase.\n$~/workdir\u003e mkdir package2 $~/workdir\u003e cat \u003c\u003cEOF \u003e package2/build.yaml requires: - name: \"foo\" category: \"bar\" version: \"\u003e=0\" steps: - source /foo \u0026\u0026 echo \"$foo\" \u003e /bar EOF $~/workdir\u003e cat \u003c\u003cEOF \u003e package2/definition.yaml name: \"ineedfoo\" version: \"0.1\" category: \"bar\" EOF $~/workdir\u003e mkdir package3 $~/workdir\u003e cat \u003c\u003cEOF \u003e package3/build.yaml requires: - name: \"foo\" category: \"bar\" version: \"\u003e=0\" - name: \"ineedfoo\" category: \"bar\" version: \"\u003e=0\" steps: - source /foo \u0026\u0026 echo \"$foo\" \u003e /ineedboth - cat /bar \u003e /bar EOF $~/workdir\u003e cat \u003c\u003cEOF \u003e package3/definition.yaml name: \"ineedfooandbar\" version: \"0.1\" category: \"bar\" EOF To build, run again:\n$\u003e luet build --all As we can see, now Luet generated 3 packages, bar/foo, bar/ineedfoo and bar/ineedfooandbar. They aren‚Äôt doing anything special than just shipping text files, this is an illustrative example on how build requirements can be combined to form new packages:\nbar/ineedfooandbar depends on both bar/ineedfoo and bar/foo during build-time, while bar/foo uses a docker image as a build base.\nSee the package definition documentation page for more details on how to instruct the Luet compiler to build packages with different strategies.\nCaching docker images Luet can push and pull the docker images that are being generated during the build process. A tree is represented by a single docker image, and each package can have one or more tags attached to it.\nTo push automatically docker images that are built, use the --push option, to pull, use the --pull option. An image repository can be specified with --image-repository flag, and can include also the remote registries where the images are pushed to.\nLuet doesn‚Äôt handle login to registries, so that has to be handled separately with docker login or img login before the build process starts.\nBuild faster When packages are cached, for iterating locally it‚Äôs particularly useful to jump straight to the image that you want to build. You can use --only-target-package to jump directly to the image you are interested in. Luet will take care of checking if the images are present in the remote registry, and would build them if any of those are missing.\nNotes  All the files which are next to a build.yaml are copied in the container which is running your build, so they are always accessible during build time. If you notice errors about disk space, mind to set the TMPDIR env variable to a different folder. By default luet respects the O.S. default (which in the majority of system is /tmp).  ","excerpt":"Prerequisistes Luet currently supports Docker and Img as backends to ‚Ä¶","ref":"/docs/docs/concepts/overview/build_packages/","title":"Building packages"},{"body":"","excerpt":"","ref":"/docs/docs/tutorials/hello_world/","title":"Hello world!"},{"body":"Prerequisites No dependencies. For building packages see the Build Packages section\nGet Luet From release Just grab a release from the release page on GitHub. The binaries are statically compiled.\nOr you can install Luet also with a single command:\ncurl https://get.mocaccino.org/luet/get_luet_root.sh | sudo sh Building Luet from source Requirements:\n Golang installed in your system. make  $\u003e git clone https://github.com/mudler/luet $\u003e cd luet $\u003e make build # or just go build Install it as a system package In the following section we will see how to install luet with luet itself. We will use a transient luet version that we are going to throw away right after we install it in the system.\n# Get a luet release. It will be used to install luet in your system wget https://github.com/mudler/luet/releases/download/0.8.3/luet-0.8.3-linux-amd64 -O luet chmod +x luet # Creates the luet configuration file and add the luet-index repository. # The luet-index repository contains a collection of repositories which are  # installable and tracked in your system as standard packages. cat \u003e .luet.yaml \u003c\u003cEOF repositories: - name: \"mocaccino-repository-index\" description: \"MocaccinoOS Repository index\" type: \"http\" enable: true cached: true priority: 1 urls: - \"https://get.mocaccino.org/mocaccino-repository-index\" EOF # Install the official luet repository to get always the latest luet version ./luet install repository/luet # Install luet (with luet) in your system ./luet install system/luet # Remove the temporary luet used for bootstrapping rm -rf luet # Copy over the config file to your system mkdir -p /etc/luet mv .luet.yaml /etc/luet/luet.yaml Configuration Luet stores its configuration files in /etc/luet. If you wish to override its default settings, create a file /etc/luet/luet.yaml.\nA example of a luet.yaml file can be found here.\nThere are a bunch of configuration settings available, but the most relevant are:\nlogging:color:true# Enable/Disable colored outputenable_emoji:true# Enable/Disable emoji from outputgeneral:debug:false# Enable/Disable debugsystem:rootfs:\"/\"# What's our rootfs. Luet can install packages outside of \"/\"database_path:\"/var/db/luet\"# Where to store DB filesdatabase_engine:\"boltdb\"tmpdir_base:\"/var/tmp/luet\"# The temporary directory to be usedAdding repositories To add repositories, you can either add a repositories stanza in your /etc/luet/luet.yaml or either add one or more yaml files in /etc/luet/repos.conf.d/.\nConfiguration in /etc/luet/luet.yaml logging:color:true# Enable/Disable colored outputenable_emoji:true# Enable/Disable emoji from outputgeneral:debug:false# Enable/Disable debugsystem:rootfs:\"/\"# What's our rootfs. Luet can install packages outside of \"/\"database_path:\"/var/db/luet\"# Where to store DB filesdatabase_engine:\"boltdb\"tmpdir_base:\"/var/tmp/luet\"# The temporary directory to be usedrepositories:- name:\"mocaccino-desktop-stable\"# Repository namedescription:\"MocaccinoOS desktop Repository (stable)\"type:\"http\"# Repository type, disk or http are supported (disk for local path)enable:true# Enable/Disable repocached:true# Enable cache for repositorypriority:3# Cache priorityurls:# Repository URLs- \"https://get.mocaccino.org/mocaccino-desktop-stable\"Configuration in /etc/luet/repos.conf.d/ A repository file can be for example:\nname:\"mocaccino-desktop-stable\"# Repository namedescription:\"MocaccinoOS desktop Repository (stable)\"type:\"http\"# Repository type, disk or http are supported (disk for local path)enable:true# Enable/Disable repocached:true# Enable cache for repositorypriority:3# Cache priorityurls:# Repository URLs- \"https://get.mocaccino.org/mocaccino-desktop-stable\"There is available a collection of repositories, which is containing a list of repositories that can be installed in the system with luet install.\nIf you installed Luet from the curl command, you just need to run luet search repository to see a list of all the available repository, and you can install them singularly by running luet install repository/\u003cname\u003e. Otherwise, add the repository stanzas you need to /etc/luet/luet.yaml.\n","excerpt":"Prerequisites No dependencies. For building packages see the Build ‚Ä¶","ref":"/docs/docs/getting-started/","title":"Getting Started"},{"body":"Luet provides an abstraction layer on top of the container image layer to make the package a first class construct. A package definition and all its dependencies are translated by Luet to Dockerfiles which can then be built anywhere that docker runs.\nLuet is written entirely in Go and comes as a single static binary. This has a few advantages:\n Easy to recover. You can use luet to bootstrap the system entirely from the ground-up. Package manager has no dependencies on the packages that it installs. There is no chance of breaking the package manager by installing a conflicting package, or uninstalling one. Portable - it can run on any architecture  Luet brings the containers ecosystem to standard software package management and delivery. It is fully built around the container concept, and leverages the huge catalog already present in the wild. It lets you use Docker images from Docker Hub, or from private registries to build packages, and helps you to redistribute them.\nSystems that are using luet as a package manager can consume Luet repositories with only luet itself. No dependency is required by the Package manager, giving you the full control on what you install or not in the system. It can be used to generate Linux from Scratch distributions, also to build Docker images, or to simply build standalone packages that you might want to redistribute.\nThe syntax proposed aims to be KISS - you define a set of steps that need to be run to build your image, and a set of constraints denoting the requirements or conflicts of your package.\nWhy another Package manager? There is no known package manager with 0-dependency that fully leverages the container ecosystem. This gap forces current package managers to depend on a specific system layout as base of the building process and the corresponding depencies. This can cause situations leading to a broken system. We want to fix that by empowering the user, by building their own packages, and redistribute them. Luet allows also to create packages entirely from Docker images content. In this way the user can actually bundle all the files of an image into a package and deliver part of it, or entirely as a layer. All of that, without the package manager depending on a single bit from it.\nPackage definitions Luet uses YAML for the package specification format, Luet parses the requirements to build packages, so Luet can consume them.\nBelow you can find links to tutorials on how to build packages, images and repositories.\n","excerpt":"Luet provides an abstraction layer on top of the container image layer ‚Ä¶","ref":"/docs/docs/concepts/overview/","title":"Overview"},{"body":"After a set of packages has been built, a repository must be created in order to make them accessible by Luet clients. A Repository can be served either local files or via http(s) (at the moment of writing). Luet, by default, supports multiple-repositories with priorities.\nCreate a repository After issuing a luet build, the built packages are present in the output build directory. The create-repo step is needed to generate a portable tree, which is read by the clients, and a repository.yaml which contains the repository metadata.\nNote that the output of create-repo is additive so it integrates with the current build content. The repository is composed by the packages generated by the build command (or pack) and the create-repo generated metadata.\nFlags Some of the relevant flags for create-repo are:\n ‚Äìdescr: Repository description ‚Äìname: Repository name ‚Äìoutput: Metadata output folder (while a different path can be specified, it‚Äôs prefered to output the metadata files directly to the package directory).This most of the time matches the packages path for convenience. ‚Äìpackages: Directory where built packages are stored. This most of the time is also the output path. ‚Äìreset-revision: Reset the repository revision number ‚Äìtree-path: Specify a custom name for the tree path. (Defaults to tree.tar) ‚Äìtree-compression: Specify a compression algorithm for the tree. (Available: gzip, Defaults: none) ‚Äìtree: Path of the tree which was used to generate the packages and holds package metadatas ‚Äìtype: Repository type (http/local). It is just descriptive, the clients will be able to consume the repo in whatsoever way it is served. ‚Äìurls: List of URIS where the repository is available  See luet create-repo --help for a full description.\nExample Build a package and generate the repository metadata:\n$\u003e mkdir package $\u003e cat \u003c\u003cEOF \u003e package/build.yaml image: busybox steps: - echo \"foo\" \u003e /foo EOF $\u003e cat \u003c\u003cEOF \u003e package/definition.yaml name: \"foo\" version: \"0.1\" category: \"bar\" # optional! EOF $\u003e luet build --all --destination $PWD/out/ --tree $PWD/package üì¶ Selecting foo 0.1 üì¶ Compiling foo version 0.1 .... ‚òï üêã Downloading image luet/cache-foo-bar-0.1-builder üêã Downloading image luet/cache-foo-bar-0.1 üì¶ foo Generating üêã definition for builder image from busybox üêã Building image luet/cache-foo-bar-0.1-builder üêã Building image luet/cache-foo-bar-0.1-builder done Sending build context to Docker daemon 4.096kB ... $\u003e luet create-repo --name \"test\" --output $PWD/out --packages $PWD/out --tree $PWD/package For repository test creating revision 1 and last update 1580641614... $\u003e ls out foo-bar-0.1-builder.image.tar foo-bar-0.1.image.tar foo-bar-0.1.metadata.yaml foo-bar-0.1.package.tar repository.yaml tree.tar Notes  The tree of definition being used to build the repository, and the package directories must not be symlinks. To build a repository is not required to hold the packages artifacts, only the respective metadata.yaml file is required.  ","excerpt":"After a set of packages has been built, a repository must be created ‚Ä¶","ref":"/docs/docs/concepts/overview/repositories/","title":"Creating Luet repositories"},{"body":"","excerpt":"","ref":"/docs/docs/concepts/","title":"Concepts"},{"body":"A Package in Luet is denoted by a triple (name, category and version), here called package form in a definition.yaml file in YAML:\nname:\"awesome\"version:\"0.1\"category:\"foo\"While category and version can be omitted, the name is required. Note that when refering to a package, the triplet is always present:\nrequires:- name:\"awesome\"version:\"0.1\"category:\"foo\"- name:\"bar\"version:\"0.1\"category:\"foo\"Building process When a package is required to be built, Luet resolves the dependency trees and orders the spec files to satisfy the given contraints.\nEach package build context is where the spec files are found (definition.yaml and build.yaml). This means that in the container, which is running the build process, the resources inside the package folder are accessible, as normally in Docker.\n‚ùØ tree distro/raspbian/buster distro/raspbian/buster ‚îú‚îÄ‚îÄ build.sh ‚îú‚îÄ‚îÄ build.yaml ‚îú‚îÄ‚îÄ definition.yaml ‚îî‚îÄ‚îÄ finalize.yaml In the example above, build.sh is accessible in build time and can be invoked easily in build time in build.yaml:\nsteps:- sh build.shPackage provides Packages can specify a list of provides. This is a list of packages in package form, which indicates that the current definition replaces every occurrence of the packages in the list (both at build and runtime). This mechanism is particularly helpful for handling package moves or for enabling virtual packages (e.g., gentoo virtual packages).\nNote: packages in the provides list don‚Äôt need to exist or have a valid build definition either.\nPackage types By a combination of keywords in build.yaml, you end up with categories of packages that can be built:\n Seed packages Packages deltas Package layers Package with includes  Check the Specfile concept page for a full overview of the available keywords in the Luet specfile format.\nSeed packages Seed packages denote a parent package (or root) that can be used by other packages as a dependency. Normally, seed packages include just an image (preferably tagged) used as a base for other packages to depend on.\nIt is useful to pin to specific image versions, and to write down in a tree where packages are coming from. There can be as many seed packages as you like in a tree.\nA seed package build.yaml example is the following:\nimage:\"alpine:3.1\"Every other package that depends on it will inherit the layers from it.\nIf you want to extract the content of the seed package in a separate packages (splitting), you can just create as many package as you wish depending on that one, and extract its content, for example:\nalpine/build.yaml\nimage:\"alpine:3.1\"alpine/definition.yaml\nname:\"alpine\"version:\"3.1\"category:\"seed\"sh/build.yaml\n# List of build-time dependenciesrequires:- name:\"alpine\"version:\"3.1\"category:\"seed\"unpack:\"true\"# Tells luet to use the image content by unpacking itincludes:- /bin/shsh/definition.yaml\nname:\"sh\"category:\"utils\"version:\"1.0\"In this example, there are two packages being specified:\n One is the seed package, which is the base image employed to later extract packages. It has no installable content, and it is just virtually used during build phase. sh is the package which contains /bin/sh, extracted from the seed image and packaged. This can be consumed by Luet clients in order to install sh in their system.  Packages delta Luet, by default, will try to calculate the delta of the package that is meant to be built. This means that it tracks incrementally the changes in the packages, to ease the build definition. Let‚Äôs see an example.\nGiven the root package: alpine/build.yaml\nimage:\"alpine:3.1\"alpine/definition.yaml\nname:\"alpine\"version:\"3.1\"category:\"seed\"We can generate any file, and include it in our package by defining this simple package:\nfoo/build.yaml\n# List of build-time dependenciesrequires:- name:\"alpine\"version:\"3.1\"category:\"seed\"steps:- echo \"Awesome\" \u003e /foofoo/definition.yaml\nname:\"foo\"category:\"utils\"version:\"1.0\"By analyzing the difference between the two packages, Luet will automatically track and package /foo as part of the foo package.\nTo allow operations that must not be accounted in to the final package, you can use the prelude keyword:\nfoo/build.yaml\n# List of build-time dependenciesrequires:- name:\"alpine\"version:\"3.1\"category:\"seed\"prelude:- echo \"Not packaged\" \u003e /invisiblesteps:- echo \"Awesome\" \u003e /foofoo/definition.yaml\nname:\"foo\"category:\"utils\"version:\"1.0\"The list of commands inside prelude that would produce artifacts, are not accounted to the final package. In this example, only /foo would be packaged (which output is equivalent to the example above).\nThis can be used, for instance, to fetch sources that must not be part of the package.\nYou can apply restrictions anytime and use the includes keyword to specifically pin to the files you wish in your package.\nPackage layers Luet can be used to track entire layers and make them installable by Luet clients.\nGiven the examples above:\nalpine/build.yaml\nimage:\"alpine:3.1\"alpine/definition.yaml\nname:\"alpine\"version:\"3.1\"category:\"seed\"An installable package derived by the seed, with the actual full content of the layer can be composed as follows:\nfoo/build.yaml\n# List of build-time dependenciesrequires:- name:\"alpine\"version:\"3.1\"category:\"seed\"unpack:true# It advertize Luet to consume the package as isfoo/definition.yaml\nname:\"foo\"category:\"utils\"version:\"1.0\"This can be combined with other keywords to manipulate the resulting package (layer), for example:\nfoo/build.yaml\n# List of build-time dependenciesrequires:- name:\"alpine\"version:\"3.1\"category:\"seed\"unpack:true# It advertize Luet to consume the package as issteps:- apk update- apk add git- apk add ..foo/definition.yaml\nname:\"foo\"category:\"utils\"version:\"1.0\"Package includes In addition, the includes keyword can be set in order to extract portions from the package image.\ngit/build.yaml\n# List of build-time dependenciesrequires:- name:\"alpine\"version:\"3.1\"category:\"seed\"unpack:true# It advertize Luet to consume the package as issteps:- apk update- apk add gitincludes:- /usr/bin/gitfoo/definition.yaml\nname:\"git\"category:\"utils\"version:\"1.0\"As a reminder, the includes keywords accepts regular expressions in the Golang format. Any criteria expressed by means of Golang regular expressions, and matching the file name (absolute path), will be part of the final package.\n","excerpt":"A Package in Luet is denoted by a triple (name, category and version), ‚Ä¶","ref":"/docs/docs/concepts/packages/","title":"Packages"},{"body":"Specfiles Luet packages are defined by specfiles. Specfiles define the runtime and builtime requirements of a package. There is an hard distinction between runtime and buildtime. A spec is composed at least by the runtime (definition.yaml) and the buildtime specification (build.yaml).\nLuet identifies the package definition by looking at directories that contains a build.yaml and a definition.yaml files. A Luet tree is merely a composition of directories that follows this convention. There is no constriction on either folder naming or hierarchy.\nExample of a tree folder hierarchy\ntree distro distro ‚îú‚îÄ‚îÄ funtoo ‚îÇ¬†‚îú‚îÄ‚îÄ 1.4 ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ build.sh ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ build.yaml ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ definition.yaml ‚îÇ¬†‚îÇ¬†‚îî‚îÄ‚îÄ finalize.yaml ‚îÇ¬†‚îú‚îÄ‚îÄ docker ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ build.yaml ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ definition.yaml ‚îÇ¬†‚îÇ¬†‚îî‚îÄ‚îÄ finalize.yaml ‚îÇ¬†‚îî‚îÄ‚îÄ meta ‚îÇ¬†‚îî‚îÄ‚îÄ rpi ‚îÇ¬†‚îî‚îÄ‚îÄ 0.1 ‚îÇ¬†‚îú‚îÄ‚îÄ build.yaml ‚îÇ¬†‚îî‚îÄ‚îÄ definition.yaml ‚îú‚îÄ‚îÄ packages ‚îÇ¬†‚îú‚îÄ‚îÄ container-diff ‚îÇ¬†‚îÇ¬†‚îî‚îÄ‚îÄ 0.15.0 ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ build.yaml ‚îÇ¬†‚îÇ¬†‚îî‚îÄ‚îÄ definition.yaml ‚îÇ¬†‚îî‚îÄ‚îÄ luet ‚îÇ¬†‚îú‚îÄ‚îÄ build.yaml ‚îÇ¬†‚îî‚îÄ‚îÄ definition.yaml ‚îú‚îÄ‚îÄ raspbian ‚îÇ¬†‚îú‚îÄ‚îÄ buster ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ build.sh ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ build.yaml ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ definition.yaml ‚îÇ¬†‚îÇ¬†‚îî‚îÄ‚îÄ finalize.yaml ‚îÇ¬†‚îú‚îÄ‚îÄ buster-boot ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ build.sh ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ build.yaml ‚îÇ¬†‚îÇ¬†‚îú‚îÄ‚îÄ definition.yaml ‚îÇ¬†‚îÇ¬†‚îî‚îÄ‚îÄ finalize.yaml Build specs Build specs are defined in build.yaml files. They denote the build-time dependencies and conflicts, together with a definition of the content of the package.\nExample of a build.yaml file:\nsteps:- echo \"Luet is awesome\" \u003e /awesomeprelude:- echo \"nooops!\"requires:- name:\"echo\"version:\"\u003e=1.0\"conflicts:- name:\"foo\"version:\"\u003e=1.0\"provides:- name:\"bar\"version:\"\u003e=1.0\"env:- FOO=barincludes:- /awesomeunpack:trueBuilding strategies Luet can create packages with different strategies:\n by delta. Luet will analyze the containers differencies to find out which files got added. You can use the prelude section to exclude certains file during analysis. by taking a whole container content by considering a single directory in the build container.  Package by delta By default Luet will analyze the container content and extract any file that gets added to it. The difference is calculated by using the container which is depending on, or either by the container which is created by running the steps in the prelude section of the package build spec:\nprelude:- # do something...steps:- # real work that should be calculated delta overBy omitting the prelude keyword, the delta will be calculated from the parent container where the build will start from.\nPackage by container content Luet can also generate a package content from a container. This is really useful when creating packages that are entire versioned rootfs. To enable this behavior, simply add unpack: true to the build.yaml. This enables the Luet unpacking features, which will extract all the files contained in the container which is built from the prelude and steps fields.\nTo include/exclude single files from it, use the includes and excludes directives.\nPackage by a folder in the final container Similarly, you can tell Luet to create a package from a folder in the build container. To enable this behavior, simply add package_dir: \"/path/to/final/dir\". The directory must represent exactly how the files will be ultimately installed from clients, and they will show up in the same layout in the final archive.\nsteps:- mkdir -p /output/usr/bin/- echo \"fancy stuff\" \u003e /output/usr/bin/mybin \u0026\u0026 chmod +x /output/usr/bin/mybinBuild time dependencies A package build spec defines how a package is built. In order to do this, Luet needs to know where to start. Hence a package must declare at least either one of the following:\n an image keyword which tells which Docker image to use as base, or a list of requires, which are references to other packages available in the tree.  They can‚Äôt be both present in the same specfile.\nTo note, it‚Äôs not possible to mix package build definitions from different image sources. They must form a unique sub-graph in the build dependency tree.\nOn the other hand it‚Äôs possible to have multiple packages depending on a combination of different requires, given they are coming from the same image parent.\nExcluding/including files explictly Luet can also exclude and include single files or folders from a package by using the excludes and includes keyword respecitvely.\nBoth of them are parsed as a list of Golang regex expressions, and they can be combined together to fine-grainly decide which files should be inside the final artifact. You can refer to the files as they were in the resulting package. So if a package produces a /foo file, and you want to exclude it, you can add it to excludes as /foo.\nKeywords Global:\n env: List of environment variables ( in NAME=value format ) that are expanded in step and in prelude. ( e.g. ${NAME} ). step: List of commands to perform in the build container. prelude: List of commands to perform in the build container before building. unpack: Boolean which indicates if the package content is the whole container content. includes: List of strings which are encoded in logical AND, they denote the content to filter from the container image to be packed. Wildcards and golang regular expressions are supported. If specified, files not matching any of the regular expressions in the list won‚Äôt be included in the final package. package_dir: Directory from within the build container which contains the final artefacts of your package excludes: List of golang regexes. They are in full path form (e.g. ^/usr/bin/foo ) and indicates that the files listed shouldn‚Äôt be part of the final artifact includes: List of golang regexes. They are in full path form (e.g. ^/usr/bin/foo ) and indicates that the files listed needs to be included as part of the final artifact  By combining excludes with includes, it‚Äôs possible to include certain files while excluding explicitly some others (excludes takes precedence over includes).\nSource from external image (e.g. Docker):\n image: docker image to be used to build the package (might be omitted)  From a tree dependency:\n requires: List of packages which it depends on. conflicts: List of packages which it conflicts with.  Rutime specs Runtime specification are denoted in a definition.yaml sibiling file. It identifies the package and the runtime contraints attached to it.\ndefinition.yaml:\nname:\"awesome\"version:\"0.1\"category:\"foo\"requires:- name:\"echo\"version:\"\u003e=1.0\"category:\"bar\"conflicts:- name:\"foo\"version:\"1.0\"provides:- name:\"bar\"version:\"\u003c1.0\"Keywords Global:\n name: Name of the package required version: Version of the package in semver notation. Selectors (\u003e=,\u003c,\u003e,\u003c=) here are not supported. You can use selectors only in dependency lists. category: Category of the package. provides: List of packages which it replaces. hidden: Boolean that indicates that the package should be hidden from luet search. Note packages can be still installed, they are just omitted to the user. You can inspect any time hidden packages with luet search --hidden  Runtime dependency list:\n requires: List of packages which it depends on, in runtime. conflicts: List of packages which it conflicts with, in runtime.  Refering to packages from the CLI All the luet commands which takes a package as argument, respect the following syntax notation:\n cat/name: will default to selecting any available package =cat/name: will default to gentoo parsing with regexp so also =cat/name-1.1 works cat/name@version: will select the specific version wanted ( e.g. cat/name@1.1 ) but can also include ranges as well cat/name@\u003e=1.1 name: just name, category is omitted and considered empty  Finalizers Finalizers are denoted in a finalize.yaml file, which is a sibiling of definition.yaml and build.yaml file. It contains a list of commands that finalize the package when it is installed in the machine.\nfinalize.yaml:\ninstall:- rc-update add docker defaultKeywords  install: List of commands to run in the host machine. Failures are eventually ignored, but will be reported and luet will exit non-zero in such case.  ","excerpt":"Specfiles Luet packages are defined by specfiles. Specfiles define the ‚Ä¶","ref":"/docs/docs/concepts/packages/specfile/","title":"Specfile"},{"body":"Installing a package To install a package with luet, simply run:\n$ luet install \u003cpackage_name\u003e Uninstalling a package To uninstall a package with luet, simply run:\n$ luet uninstall \u003cpackage_name\u003e Upgrading the system To upgrade your system, simply run:\n$ luet upgrade Searching a package To search a package:\n$ luet search \u003cregex\u003e To search a package and display results in a table:\n$ luet search --table \u003cregex\u003e To look into the installed packages:\n$ luet search --installed \u003cregex\u003e Note: the regex argument is optional\nSearch output Search can return results in the terminal in different ways: as terminal output, as json or as yaml.\nJSON $ luet search --json \u003cregex\u003e YAML $ luet search --yaml \u003cregex\u003e Tabular $ luet search --table \u003cregex\u003e ","excerpt":"Installing a package To install a package with luet, simply run:\n$ ‚Ä¶","ref":"/docs/docs/concepts/overview/managing_packages/","title":"Managing packages"},{"body":"Catclock example In this example, we will build the awesome CatClock on containers we will run it locally in a Luet box.\nWe will do this experiment to prove two things:\n how we can build a package with Luet and two packages from different distributions can (sometime) work together.  Prerequisites To build packages with Luet, you must have installed Docker and container-diff, follow our setup guide.\n1) Create the package To prove our point, we will build our package from an OpenSUSE image, and later on we will consume entropy repositories for runtime dependencies. To note, this is not the main focus of Luet, and this is a restricted example on its features on build-time resolution. For more syntax examples, see also Build specs and Package types.\nRun this commands in any directory you choose to be your workspace:\n# Let's create a directory to store our package spec: mkdir -p tree/misc/catclock/ 1.1) Build spec Now, let‚Äôs generate our build spec:\n# Create a build file. We use here opensuse/leap to build the package, as an example cat \u003c\u003cEOF \u003e tree/misc/catclock/build.yaml image: opensuse/leap # Preparation phase prelude: - zypper in -y git make libXt-devel xmh gcc motif-devel libXext-devel libpulse-devel libaubio-devel - git clone https://github.com/BarkyTheDog/catclock # Here we define the steps that Luet will follow steps: - cd catclock \u0026\u0026 make DEFINES=\"-Wno-incompatible-pointer-types\" - mv catclock/xclock /usr/bin/xclock # (optional) File list that will be included in the final package # Luet will filter out files that won't match any entry in the list (regex syntax IS supported) includes: - /usr/bin/xclock EOF build.yaml is what an ebuild is for Gentoo and for e.g. what PKGBUILD is for Arch.\n image: opensuse/leap tells luet to use opensuse/leap as a build image. We collect the build time dependencies with zypper (the openSUSE package manager), and the CatClock with git. When we declare an image keyword in a spec, it becomes a seed package ( Package types ) as doesn‚Äôt depend on any package in build time, we will cover more use cases in other examples. prelude is a list of commands that will happen during the build phase. They might generate binaries, or download sources, but those are not took into consideration when generating the final package. steps is a list of commands that will happen during the build phase. Luet will execute those commands and all the binaries generated from them become part of the final package includes is a (optional) list of regex that tells to Luet what files to filter out from the final artifact.  1.2) Runtime spec Now we generate the runtime spec, it‚Äôs the part about the binary end which will be installed in the system. It also holds the metadata relative to the package definition (name, category, version).\n# Create a runtime definition. # We will leverage packages already present on Sabayon Entropy repositories # the end-system needs to have the Luet Sabayon Entropy repositories enabled. cat \u003c\u003cEOF \u003e tree/misc/catclock/definition.yaml category: \"misc\" name: \"catclock\" version: \"0.20200318\" requires: - category: meta name: users version: \"\u003e=0\" - category: x11-libs name: motif version: \"\u003e=0.1\" - category: media-libs name: libjpeg-turbo version: \"\u003e=0.1\" EOF  category, name, and version: identifies the package in a Luet tree. This is the unique identifier for a package. requires it‚Äôs a list of packages which our catclock depends on during runtime (when we will execute catclock inside a small-container!). To find out what‚Äôs required by your binaries it can be a try-learn-fail effort. If the package you wish to build is specifying the deps it requires, and those are available in a Luet repository, you are all set, just point them there. Otherwise you have to figure out after you build the binary the first time (for example, with ldd) to which libraries it depends on. In this example we consume the dependencies from the Luet Entropy Repo, that we will enable on the following steps.  2) Build it! sudo /usr/bin/luet build \\ --tree=$PWD/tree misc/catclock \\ --destination $PWD/build \\ --compression gzip sudo chown -R $USER $PWD/build # So later on, we can access to the repository with our user We are building the specs in this step.\n tree: is the path where our specs are, in our case it‚Äôs tree. destination: is the path where our packages will be stored, in our case this is build. compression: is the compression algorithm used to compress the final artifacts  Note, we need sudo to keep the permissions properly mapped in the artifact which is produced this is not always the case. Depends on the package content.\n3) Create a local repository We will generate now our repository metadata:\n/usr/bin/luet create-repo --tree \"tree\" \\ --output $PWD/build \\ --packages $PWD/build \\ --name \"test repo\" \\ --descr \"Test Repo\" \\ --tree-compression gzip \\ --meta-compression gzip Creating a repository in Luet is about adding metadata and make our spec tree available to other systems running Luet to intall the package.\n output: a path which is where Luet will store the repository metadata. packages: a path containing the packages that were built during the build step name: Repository name descr: Repository description tree-compression: optional, algorithm to use when compression the tree metadata meta-compression: optional, algorithm to use when compression the repository metadata  4) Let‚Äôs test it! Now we are all set. We have the packages compiled, and we are ready to consume them. We don‚Äôt want to break our host system, and we want to test this from our user.\nLet‚Äôs create a directory, we will try to setup a full running system, and install everything there.\n# Let's create a directory for our \"fake\" rootfilesystem # it will be populated with a minimal set of packages needed to run  # our amazing catclock mkdir -p $PWD/rootfs # Let's also create a directory to store our config files mkdir -p $PWD/conf We will generate now a Luet config. The Luet config is used to read where install things from, and in which directory. It also lists the repositories that are used by the client to retrieve packages remotely.\n# We create here a config file which references the rootfs. # In this way, luet instead installing packages to your host system, will populate the rootfs # (note, all the steps are run by a user here, no root required!) cat \u003c\u003cEOF \u003e conf/luet-dso-local.yaml system: rootfs: $PWD/rootfs # our \"fake\" rootfs that we created before database_path: \"/\" # this is where our Luet DB will live database_engine: \"boltdb\" # this is the Luet DB engine repositories: - name: \"main\" type: \"disk\" priority: 3 enable: true urls: - \"$PWD/build\" # This is the repository we have created before! - name: \"sabayonlinux.org\" description: \"Sabayon Linux Repository\" type: \"http\" enable: true cached: true priority: 2 urls: - \"https://dispatcher.sabayon.org/sbi/namespace/luet-entropy-repo\" - name: \"luet-repo\" description: \"Luet Official Repository\" type: \"http\" enable: true cached: true priority: 1 urls: - \"https://raw.githubusercontent.com/Luet-lab/luet-repo/gh-pages\" EOF # we have specified an additional repository, one that is luet-entropy-repo (which contains # the runtime dependencies we specified in our package) # Let's populate our rootfs with some minimal things: base-gcc, and bash # meta/users is a meta package providing minimal base to run things with a full # user-level support. export LUET_NOLOCK=true luet install \\ --config $PWD/conf/luet-dso-local.yaml \\ meta/users # catclock is a X11 app! we want to be able to play with it locally from our host :) # Let's copy the .Xauthority file to allow the X app to communicate with our X server # Note: This can be achieved in other ways (set up a tcp X server, and so on) cp -rfv $HOME/.Xauthority $PWD/rootfs/ luet install \\ --config $PWD/conf/luet-dso-local.yaml \\ misc/catclock # Let's run our beautiful catclock :) luet box exec --rootfs $PWD/rootfs \\ --stdin --stdout --stderr --env DISPLAY=$DISPLAY \\ --env XAUTHORITY=/.Xauthority --mount /tmp --entrypoint /usr/bin/xclock Spawn a bash shell inside our box (with permission to access to our running X):\nluet box exec --rootfs $PWD/rootfs \\ --stdin --stdout --stderr --env DISPLAY=$DISPLAY \\ --env XAUTHORITY=/.Xauthority --mount /tmp --entrypoint /bin/bash ","excerpt":"Catclock example In this example, we will build the awesome CatClock ‚Ä¶","ref":"/docs/docs/tutorials/build_package/","title":"Build a package"},{"body":"Luet can be extended in 2 ways by extensions and plugins.\nBefore you begin You need to have a working luet binary installed.\nExtensions Extensions expand Luet featureset horizontally, so for example, ‚Äúluet geniso‚Äù will allow you to build an iso using luet, without this needing to be part of the luet core.\nAn Extension is nothing more than a standalone executable file, whose name begins with luet-. To install an extension, simply move its executable file to anywhere on your system PATH.\nAll the plugins will be accessible to luet as luet pluginname\nWriting an Extension You can write an extension in any programming language or script that allows you to write command-line commands.\nExecutables receive the inherited environment from luet. An extension determines which command path it wishes to implement based on its name. For example, a plugin wanting to provide a new command luet foo, would simply be named luet-foo, and live somewhere in your PATH.\nExample Extension #!/bin/bash  if [[ \"$1\" == \"help\" ]] then echo \"Extension help\" exit 0 fi if [[ \"$1\" == \"run\" ]] then # do something interesting fi echo \"I am an Extension named luet-foo\" Using an Extension To use the above extension, simply make it executable:\n$ sudo chmod +x ./luet-foo and place it anywhere in your PATH:\n$ sudo mv ./luet-foo /usr/local/bin You may now invoke your extension as a luet command:\n$ luet foo I am an Extension named luet-foo All args and flags are passed as-is to the executable:\n$ luet foo help Extension help Plugins Plugins instead are expanding Luet vertically by hooking into internal events. Plugins and Extensions can be written in any language, bash included! Luet uses go-pluggable so it can dispatch events to external binaries.\nSimilarly to Extensions, a Plugin is nothing more than a standalone executable file, but without any special prefix. To install a plugin, simply move its executable file to anywhere on your system PATH.\nDifferently from Extensions, they are not available from the CLI and cannot be invoked directly by the user, instead they are called by Luet during its lifecycle.\nWriting a Plugin You can write a plugin in any programming language or script.\nThe first argument that is passed to a plugin will always be the event that was emitted by Luet in its lifecycle. You can see all the events available here. The second argument, is a JSON encoded payload of the object that Luet is emitting with the event. The object(s) may vary depending on the emitted event.\nExample Plugin #!/bin/bash echo \"$1\" \u003e\u003e /tmp/event.txt echo \"$2\" \u003e\u003e /tmp/payload.txt Using a plugin To use the above plugin, simply make it executable:\n$ sudo chmod +x ./test-foo and place it anywhere in your PATH:\n$ sudo mv ./test-foo /usr/local/bin Now, when running luet, add --plugin test-foo:\n$ luet --plugin test-foo install -y foopackage And check /tmp/event.txt to see the event fired and /tmp/payload.txt to check the payloads that were emitted by Luet.\n","excerpt":"Luet can be extended in 2 ways by extensions and plugins.\nBefore you ‚Ä¶","ref":"/docs/docs/concepts/plugins-and-extensions/","title":"Plugins and Extensions"},{"body":"Luet supports the helm rendering engine template. It‚Äôs being used to interpolate build.yaml and finalize.yaml files before their execution.\nThe build.yaml and finalize.yaml files are rendered during build time, and it‚Äôs possible to use the helm templating syntax inside such files.\nGiven the following definition.yaml:\nname:\"test\"category:\"foo\"version:\"1.1\"additional_field:\"baz\"A build.yaml can look like the following, and interpolates it‚Äôs values during build time:\nimage:...steps:- echo {{.Values.name}} \u003e /package_name- echo {{.Values.additional_field}} \u003e /extraWhich would be for example automatically rendered by luet like the following:\nimage:...steps:- echo test \u003e /package_name- echo baz \u003e /extraThis mechanism can be used in collections as well, and each stanza in packages is used to interpolate each single package.\nReferences  Helm Template syntax guide Helm Templating functions Helm Templating variable  Examples  https://github.com/mocaccinoOS/mocaccino-musl-universe/tree/master/multi-arch/packages/tar  ","excerpt":"Luet supports the helm rendering engine template. It‚Äôs being used to ‚Ä¶","ref":"/docs/docs/concepts/packages/templates/","title":"Templated packages"},{"body":"Here we show an example on how to build ‚Äúburnable‚Äù SD images for Raspberry Pi with Luet. This approach lets you describe and version OTA upgrades for your embedded devices, delivering upgrades as layer upgrades on the Pi.\nThe other good side of the medal is that you can build a Luet package repository with multiple distributions (e.g. Raspbian, OpenSUSE, Gentoo, ‚Ä¶ ) and switch among them in runtime. In the above example Raspbian and Funtoo (at the time of writing) are available.\nPrerequisites You have to run the following steps inside an ARM board to produce arm-compatible binaries. Any distribution with Docker will work. Note that the same steps could be done in a cross-compilation approach, or with qemu-binfmt in a amd64 host.\nYou will also need in your host:\n Docker Luet installed (+container-diff) in /usr/bin/luet (arm build) make  Build the packages Clone the repository https://github.com/Luet-lab/luet-embedded\n$\u003e git clone https://github.com/Luet-lab/luet-embedded $\u003e cd luet-embedded $\u003e sudo make build-all ...  If a rebuild is needed, just do sudo make rebuild-all after applying the changes.\nCreate the repository $\u003e sudo make create-repo ...  Serve the repo locally $\u003e make serve-repo ...  Create the flashable image Funtoo based system $\u003e sudo LUET_PACKAGES='distro/funtoo-1.4 distro/raspbian-boot-0.20191208 system/luet-develop-0.5' make image ...  Raspbian based system $\u003e sudo LUET_PACKAGES='distro/raspbian-0.20191208 distro/raspbian-boot-0.20191208 system/luet-develop-0.5' make image ...  At the end of the process, a file luet_os.img, ready to be flashed to an SD card, should be present in the current directory.\nAdd packages In order to build and add packages to the exiting repository, simply add or edit the specfiles under the distro folder. When doing make rebuild-all the packages will be automatically compiled and made available to the local repository.\n","excerpt":"Here we show an example on how to build ‚Äúburnable‚Äù SD images for ‚Ä¶","ref":"/docs/docs/resources/arm/","title":"ARM images"},{"body":"Simple package build Creating and building a simple package:\n$\u003e mkdir package $\u003e cat \u003c\u003cEOF \u003e package/build.yaml image: busybox steps: - echo \"foo\" \u003e /foo EOF $\u003e cat \u003c\u003cEOF \u003e package/definition.yaml name: \"foo\" version: \"0.1\" EOF $\u003e luet build --all üì¶ Selecting foo 0.1 üì¶ Compiling foo version 0.1 .... ‚òï üêã Downloading image luet/cache-foo-bar-0.1-builder üêã Downloading image luet/cache-foo-bar-0.1 üì¶ foo Generating üêã definition for builder image from busybox üêã Building image luet/cache-foo-bar-0.1-builder üêã Building image luet/cache-foo-bar-0.1-builder done Sending build context to Docker daemon 4.096kB ... Build packages In order to build a specific version, a full package definition (triple of category, name and version) has to be specified. In this example we will also enable package compression (gzip).\n$\u003e mkdir package $\u003e cat \u003c\u003cEOF \u003e package/build.yaml image: busybox steps: - echo \"foo\" \u003e /foo EOF $\u003e cat \u003c\u003cEOF \u003e package/definition.yaml name: \"foo\" version: \"0.1\" category: \"bar\" EOF $\u003e luet build bar/foo-0.1 --compression gzip üì¶ Selecting foo 0.1 üì¶ Compiling foo version 0.1 .... ‚òï üêã Downloading image luet/cache-foo-bar-0.1-builder üêã Downloading image luet/cache-foo-bar-0.1 üì¶ foo Generating üêã definition for builder image from busybox üêã Building image luet/cache-foo-bar-0.1-builder üêã Building image luet/cache-foo-bar-0.1-builder done Sending build context to Docker daemon 4.096kB ... ","excerpt":"Simple package build Creating and building a simple package:\n$\u003e mkdir ‚Ä¶","ref":"/docs/docs/resources/building/","title":"Building"},{"body":"Collections are a special superset of packages. To define a collection, instead of using a definition.yaml file, create a collection.yaml file with a list of packages:\npackages:- name:\"foo\"category:\"bar\"version:\"1.1\"...Packages under a collection shares the same build.yaml and finalize.yaml, so a typical package layout can be:\ncollection/ collection.yaml build.yaml finalize.yaml ... additional files in the build context Luet during the build phase, will treat packages of a collection individually. A collection is a way to share the same build process across different packages.\nTemplating The templating mechanism can be used in collections as well, and each stanza in packages is used to interpolate each single package.\nExamples  https://github.com/mocaccinoOS/mocaccino-musl-universe/tree/master/multi-arch/packages/entities https://github.com/mocaccinoOS/portage-tree/tree/master/multi-arch/packages/groups https://github.com/mocaccinoOS/mocaccino-musl-universe/tree/master/multi-arch/packages/X  ","excerpt":"Collections are a special superset of packages. To define a ‚Ä¶","ref":"/docs/docs/concepts/packages/collections/","title":"Collections"},{"body":"Under the hood, Luet uses boolean satisfiability problem (SAT) reinforcement learning techniques to solve package constraints.\nLuet allows you to specify 3 types of set of contraints on a package definition:\n Requires Conflicts Provides  The package definition in your tree definition, along with its Requires and Conflicts, are turned into Boolean formulas that are consumed by the solver to compute a solution. The solution represent the state of your system after a particular query is asked to the solver (Install, Uninstall, Upgrade).\nRequires and Conflicts A list of requires and conflicts, composed of one or more packages, becomes a SAT formula. The formula is then given to the SAT solver to compute a finite state set of packages which must be installed in the system in order to met the requirements.\nAs Luet allows to express constraints with selectors ( e.g. A depends on \u003e=B-1.0) it generates additional constraints to guarantee that at least one package and at most one is picked as dependency (ALO and AMO).\nProvides Provides constraints are not encoded in a SAT formula. Instead, they are expanded into an in-place substitution of the packages that they have to be replaced with. They share the same SAT logic of expansion, allowing to swap entire version ranges (e.g. \u003e=1.0), allowing to handle package rename, removals, and virtuals.\nReferences  OPIUM (Luet is inspired by it): https://ranjitjhala.github.io/static/opium.pdf FROM TRACTABLE CSP TO TRACTABLE SAT: https://www.cs.ox.ac.uk/files/4014/maxclosed_orderencoding_v16_TR.pdf Solver concepts applied to packages (zypper): https://en.opensuse.org/openSUSE:Libzypp_satsolver_basics  ","excerpt":"Under the hood, Luet uses boolean satisfiability problem (SAT) ‚Ä¶","ref":"/docs/docs/concepts/overview/constraints/","title":"CSP, SAT \u0026\u0026 RL"},{"body":"The Docker image quay.io/luet/base is a scratch Docker image always kept up-to-date with the latest luet version. That image can be used to bootstrap new images with Luet repositories with the packages you want, from the repositories you prefer.\nFor example we can mount a config file, and later on install a package:\ncat \u003c\u003cEOF \u003e $PWD/luet.yaml repositories: - name: \"micro-stable\" enable: true cached: true priority: 1 type: \"http\" urls: - \"https://get.mocaccino.org/moacccino-micro-stable\" EOF docker rm luet-runtime-test || true docker run --name luet-runtime-test \\  -ti -v /tmp:/tmp \\  -v $PWD/luet.yaml:/etc/luet/luet.yaml:ro \\  quay.io/luet/base install shells/bash docker commit luet-runtime-test luet-runtime-test-image # Try your new image! docker run -ti --entrypoint /bin/bash --rm luet-runtime-test-image In this way we will create a new image, with only luet and bash, and nothing else from a scratch image.\n","excerpt":"The Docker image quay.io/luet/base is a scratch Docker image always ‚Ä¶","ref":"/docs/docs/resources/scratch/","title":"Images from scratch"},{"body":"","excerpt":"","ref":"/docs/docs/tutorials/","title":"Tutorials"},{"body":"","excerpt":"","ref":"/docs/docs/contribution-guidelines/","title":"Contribution Guidelines"},{"body":"","excerpt":"","ref":"/docs/docs/resources/","title":"Resources"},{"body":"Luet is a Package Manager based on containers. It provides an abstraction layer over container specfile format, enhancing the image resolution process of open container inititative (OCI) runtimes with boolean satisfiability problem (SAT) solving techniques.\nLuet can be used to build packages, container images, as well as to manage and distribute installations of derived packages locally.\nAllows to apply semver constraints to Image dependencies, treating it as a classical CSP.\n","excerpt":"Luet is a Package Manager based on containers. It provides an ‚Ä¶","ref":"/docs/docs/","title":"Documentation"},{"body":"","excerpt":"","ref":"/docs/blog/news/","title":"News About Luet"},{"body":"","excerpt":"","ref":"/docs/blog/releases/","title":"New Releases"},{"body":"This release comes with a lot of bugfixes and enhancement to the SAT solver core:\n Add support for provides. They allow to have virtual packages which can be replaced during solving by other drop-in packages. Tons of fixes Preparation for upcoming compression support  ","excerpt":"This release comes with a lot of bugfixes and enhancement to the SAT ‚Ä¶","ref":"/docs/blog/2019/12/23/0.3-release/","title":"0.3 Release"},{"body":"Finally the website is up! Docs are a work in progress. Stay tuned for more upcoming updates\n","excerpt":"Finally the website is up! Docs are a work in progress. Stay tuned for ‚Ä¶","ref":"/docs/blog/2019/12/23/website-is-up/","title":"Website is up"},{"body":"","excerpt":"","ref":"/docs/index.json","title":""},{"body":"  #td-cover-block-0 { background-image: url(/docs/about/featured-background_hu3d03a01dcc18bc5be0e67db3d8d209a6_806797_960x540_fill_q75_catmullrom_bottom.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/docs/about/featured-background_hu3d03a01dcc18bc5be0e67db3d8d209a6_806797_1920x1080_fill_q75_catmullrom_bottom.jpg); } }  About Luet Luet is a Package Manager which uses Containers technologies.        Luet uses Container technologies ( Docker, img ) to build packages. It provides an abstraction over the Dockerfile format introducing relation and versioning of images.     Zero-deps installer The installer can run in \"from scratch\" environment - your system will be always recoverable - everything which was built from containers can be installed locally.       In few commands it allows you to switch between multiple Linux Distributions, in runtime!     ","excerpt":"  #td-cover-block-0 { background-image: ‚Ä¶","ref":"/docs/about/","title":"About Luet"},{"body":"This is the blog section. It has two categories: News and Releases.\nFiles in these directories will be listed in reverse chronological order.\n","excerpt":"This is the blog section. It has two categories: News and Releases. ‚Ä¶","ref":"/docs/blog/","title":"Luet Blog"},{"body":"","excerpt":"","ref":"/docs/community/","title":"Community"},{"body":"  #td-cover-block-0 { background-image: url(/docs/featured-background_hu3d03a01dcc18bc5be0e67db3d8d209a6_291319_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/docs/featured-background_hu3d03a01dcc18bc5be0e67db3d8d209a6_291319_1920x1080_fill_q75_catmullrom_top.jpg); } }  Luet Documentation   Download   Container Package Manager\n\n\u003c/div\u003e          Luet uses Container technologies ( Docker, img ) to build packages. It provides an abstraction over the Dockerfile format introducing relation and versioning of images.       SAT Solver Luet uses SAT Solving techniques to compute the dependencies graph. This allows to refer to docker images by using semver constraints.\nNo Relational db is involved.\n   Contributions welcome! If you like to play with code, check out our issues that are marked as ‚Äúgood first issue‚Äù and open a Pull Request on GitHub. New users are always welcome, and have fun!\nRead more ‚Ä¶\n   Container-based Use container abstraction to define your package repositories\n     Releasing is not anymore a nightmare You can carefully pick now dependencies to make your release - release composed of container images or either of a set of packages         Package Management Build, ship and delivery your software. Faster\n   0 dep installer When Luet is used as installer, it has zero dependencies.\nYour system can‚Äôt break anymore\n   Reconstruct images Thanks to its SAT core, Luet can reconstruct images defined by dependencies and version constraints.\nBuilding a de-facto tree of container images\n    ","excerpt":"  #td-cover-block-0 { background-image: ‚Ä¶","ref":"/docs/","title":"Luet docs"},{"body":"","excerpt":"","ref":"/docs/search/","title":"Search Results"}]